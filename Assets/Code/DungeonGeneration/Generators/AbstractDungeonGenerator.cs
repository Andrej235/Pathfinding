using Assets.Code.DungeonGeneration.Models;
using Assets.Code.Grid;
using Assets.Code.PathFinding;
using Assets.Code.Utility;
using CodeMonkey.Utils;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Tilemaps;

#nullable enable
public abstract class AbstractDungeonGenerator : MonoBehaviour
{
    [SerializeField] private Tilemap? floorTilemap;
    [SerializeField] private Tilemap? wallTilemap;

    protected TilemapVisualizer? tileMapVisualizer;
    [SerializeField] protected DungeonParametersSO? parameters;
    [SerializeField] protected Vector2Int startPosition;
    private Grid<PathNode>? grid;
    protected Pathfinding pathfinding = null!;
    protected Dungeon dungeonData = new();

    public Pathfinding DungeonPathfinding => pathfinding;
    public Grid<PathNode>? DungeonGrid => grid;
    public Dungeon DungeonData => dungeonData;

    /// <summary>
    /// Begins the procedural generation
    /// </summary>
    public void GenerateDungeon()
    {
        tileMapVisualizer = new(parameters, floorTilemap, wallTilemap);
        tileMapVisualizer.Clear();

        for (int i = transform.childCount; i > 0; --i)
            DestroyImmediate(transform.GetChild(0).gameObject);

        dungeonData.Reset();

        grid = RunProceduralGeneration().GeneratePathNodeGrid();
        pathfinding = new Pathfinding(grid);

        AsignRoomTypes();

        foreach (var room in dungeonData.Rooms)
        {
            PlaceProps(room);
            room.UpdateTilesAccessibleFromPath();
            SpawnEnemies(room);
        }
    }

    /// <summary>
    /// Asigns room types to room generated by <see cref="RunProceduralGeneration"/> based on <see cref="parameters"/>
    /// </summary>
    private void AsignRoomTypes()
    {
        if (parameters == null)
            return;

        var startRoomParameters = parameters.roomParameters.FirstOrDefault(x => x.Type.HasFlag(Room.RoomType.Start));
        if (startRoomParameters is null)
            return;

        var startRoom = dungeonData.Rooms.GetRandomElement();
        startRoom.Parameters = startRoomParameters;

        var rooms = dungeonData.Rooms.OrderBy(x => pathfinding?.FindPath(startRoom.RoomCenter, x.RoomCenter)?.Count);

        var bossRoomParameters = parameters.roomParameters.Where(x => x.Type.HasFlag(Room.RoomType.Boss)).ToList();

        //The furthest room is supposed to be the boss room
        var bossRoom = rooms.Last();

        if (bossRoomParameters.Count > 0)
            bossRoom.Parameters = bossRoomParameters.GetByChance();

        var excludedRooms = new List<Room>() { startRoom, bossRoom };

        foreach (var room in rooms.Except(excludedRooms))
            room.Parameters = parameters.roomParameters.GetByChance();
    }

    /// <summary>
    /// Places props inside of a given room based on <see cref="parameters"/>
    /// </summary>
    protected abstract void PlaceProps(Room room);

    /// <summary>
    /// Spawn enemies inside of a given room based on <see cref="parameters"/>
    /// </summary>
    protected abstract void SpawnEnemies(Room room);

    /// <summary>
    /// Generates a dungeon
    /// </summary>
    /// <returns>An IEnumerable<Vector2Int> where each element represents a position of a wall</returns>
    protected abstract IEnumerable<Vector2Int> RunProceduralGeneration();

}
